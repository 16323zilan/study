(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{167:function(e,n,t){"use strict";t.r(n);var i=t(0),a=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff算法","aria-hidden":"true"}},[e._v("#")]),e._v(" Diff算法")]),e._v(" "),t("h4",{attrs:{id:"_1、前言介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、前言介绍","aria-hidden":"true"}},[e._v("#")]),e._v(" 1、前言介绍")]),e._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[e._v("Introduction")]),e._v(" "),t("p",[e._v("React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。")])]),e._v(" "),t("h4",{attrs:{id:"_1、什么是dom-diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是dom-diff算法","aria-hidden":"true"}},[e._v("#")]),e._v(" 1、什么是DOM Diff算法")]),e._v(" "),t("ul",[t("li",[e._v("Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。")]),e._v(" "),t("li",[e._v("即给定任意两棵树，找到最少的转换步骤。达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度由O(n^3)直接降低到O(n)")])]),e._v(" "),t("h4",{attrs:{id:"_3、diff算法的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、diff算法的作用","aria-hidden":"true"}},[e._v("#")]),e._v(" 3、Diff算法的作用")]),e._v(" "),t("p",[e._v("计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。")]),e._v(" "),t("h5",{attrs:{id:"a-传统diff算法的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-传统diff算法的作用","aria-hidden":"true"}},[e._v("#")]),e._v(" a.传统diff算法的作用")]),e._v(" "),t("p",[e._v("计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。\nReact 使用 JSX 来替代常规的 JavaScript")]),e._v(" "),t("h4",{attrs:{id:"_4、调和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、调和","aria-hidden":"true"}},[e._v("#")]),e._v(" 4、调和")]),e._v(" "),t("ul",[t("li",[e._v("将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。")]),e._v(" "),t("li",[e._v("React diff算法是调和的具体实现。")])]),e._v(" "),t("h4",{attrs:{id:"_5、diff策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、diff策略","aria-hidden":"true"}},[e._v("#")]),e._v(" 5、diff策略")]),e._v(" "),t("p",[e._v("React用三大策略将O(n^3)复杂度转化为O(n)复杂度,执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同。")]),e._v(" "),t("blockquote",[t("p",[e._v("策略一（tree diff）：")])]),e._v(" "),t("p",[e._v("Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。新旧DOM树逐层对比的过程就是tree diff；当DOM树逐层对比完成后，即可找到所有需要被更新的元素,这样只需要对DOM树进行一次遍历，就可以完成整个树的比较;复杂度变为O(n)。")]),e._v(" "),t("p",[e._v("Tree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，A节点及其子节点被整个移动到D节点下面去，由于React只会简单的考虑同级节点的位置变换，而对于不同层级的节点，只有创建和删除操作，所以直接删掉A、B、C组件；继续第三层，当D发现多了一个子节点A，就会创建新的A作为其子节点,重新创建A、B、C组件。此时，diff的执行情况是：")]),e._v(" "),t("ul",[t("li",[e._v("createA--\x3ecreateB--\x3ecreateC--\x3edeleteA\n"),t("img",{attrs:{src:"https://img-blog.csdn.net/2018071718264787",alt:"cmd-markdown-Tree DIFF"}})])]),e._v(" "),t("p",[e._v("由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是会进行删除，重新创建的动作，这是一种很影响React性能的操作。因此官方也不建议进行DOM节点跨层级的操作。")]),e._v(" "),t("blockquote",[t("p",[e._v("策略二（component diff）：")])]),e._v(" "),t("ul",[t("li",[e._v("拥有相同类的两个组件 生成相似的树形结构，暂时认为该组件不需要被更新；")]),e._v(" "),t("li",[e._v("拥有不同类的两个组件 生成不同的树形结构。将旧的组件移除并创建新的组件，同时将组件追加到页面。")]),e._v(" "),t("li",[e._v("如果是同一个类型的组件，有可能经过一轮Virtual DOM比较下来，并没有发生变化。如果我们能够提前确切知道这一点，那么就可以省下大量的diff运算时间。因此，React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。")])]),e._v(" "),t("p",[e._v("如下图所示，当组件D变为组件G时，即使这两个组件结构相似，一旦React判断D和G是不用类型的组件，就不会比较两者的结构，而是直接删除组件D，重新创建组件G及其子节点。虽然当两个组件是不同类型但结构相似时，进行diff算法分析会影响性能，但是毕竟不同类型的组件存在相似DOM树的情况在实际开发过程中很少出现，因此这种极端因素很难在实际开发过程中造成重大影响。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdn.net/20180717182802621",alt:"cmd-markdown-Tree DIFF"}})]),e._v(" "),t("p",[e._v("如图所示，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建。")]),e._v(" "),t("blockquote",[t("p",[e._v("策略三（element diff）：")])]),e._v(" "),t("p",[e._v("Element DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdn.net/20180717182842111",alt:"cmd-markdown-Element DIFF"}})]),e._v(" "),t("h4",{attrs:{id:"_6、列表对比算法源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、列表对比算法源码分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 6、列表对比算法源码分析")]),e._v(" "),t("h5",{attrs:{id:"该js的作用是：深度遍历两个列表数据，每层的节点进行对比，记录下每个节点的差异。并返回该对象的差异。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#该js的作用是：深度遍历两个列表数据，每层的节点进行对比，记录下每个节点的差异。并返回该对象的差异。","aria-hidden":"true"}},[e._v("#")]),e._v(" 该js的作用是：深度遍历两个列表数据，每层的节点进行对比，记录下每个节点的差异。并返回该对象的差异。")]),e._v(" "),t("p",[e._v("@return {Object} {children: [], moves: [] }\nchildren 是源列表 根据 新列表返回 移动或新增的数据。")]),e._v(" "),t("p",[e._v("比如")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("oldList = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];\nnewList = [{id: 2}, {id: 3}, {id: 1}]; \n")])])]),t("p",[e._v("最后返回的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("children = [\n  {id: 1},\n  {id: 2},\n  {id: 3},\n  null,\n  null,\n  null\n ]\n")])])]),t("p",[e._v("moves 是源列表oldList 根据新列表newList 返回的操作，children为null的话，依次删除掉掉，因此返回的是")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("moves = [\n  {type: 0, index:3},\n  {type: 0, index: 3},\n  {type: 0, index: 3},\n  {type: 0, index: 0},\n  {type: 1, index: 2, item: {id: 1}}\n]\n")])])]),t("h5",{attrs:{id:"type-0-是删除操作，-type-1-是新增操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#type-0-是删除操作，-type-1-是新增操作","aria-hidden":"true"}},[e._v("#")]),e._v(" type = 0 是删除操作， type = 1 是新增操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("oldList = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}]; \nnewList = [{id: 2}, {id: 3}, {id: 1}];\n")])])]),t("p",[e._v("所以oldList根据newList来对比，{id: 4} 和 {id: 5} 和 {id: 6} 在新节点 newList没有找到，因此在moves设置为 {type:0, index:3},\n所以oldList数据依次变为 [{id: 1}, {id: 2}, {id: 3}, {id: 5}, {id: 6}] 和  [{id: 1}, {id: 2}, {id: 3}, {id: 6}] 和  [{id: 1}, {id: 2}, {id: 3}]\n每次在moves存储了一次的话，原数组会删掉当前的一项，因此oldList 变为 [{id: 1}, {id: 2}, {id: 3}], newList 为 [{id: 2}, {id: 3}, {id: 1}],\n然后各自取出该值进行比较，也就是 oldList变为 [1, 2, 3], newList变为 [2, 3, 1]; 因此oldList相对于 newList来讲的话，第一项不相同就删掉该项 所以moves新增一项{type: 0, index:0}, index从0开始的，表示第一项被删除，然后第二项1被添加，因此moves再加一项 {type: 1, index:2, item: {id: 1}}；")]),e._v(" "),t("h5",{attrs:{id:"理解代码如下："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#理解代码如下：","aria-hidden":"true"}},[e._v("#")]),e._v(" 理解代码如下：")]),e._v(" "),t("p",[e._v("该方法需要传入三个参数 oldLsit, newList, key;\noldList 和 newList 是原始数组 和 新数组， key是根据键名进行匹配。")]),e._v(" "),t("p",[e._v("现在分别对oldList 和 newList 传值如下数据：\nvar oldLsit = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];\nvar newList = [{id: 2}, {id: 3}, {id: 1}];")]),e._v(" "),t("p",[e._v("因此 var oldMap = makeKeyIndexAndFree(oldList, key);\nmakeKeyIndexAndFree代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function makeKeyIndexAndFree(list, key) {\n  var keyIndex = {};\n  var free = [];\n  for (var i = 0, len = list.length; i < len; i++) {\n    var item = list[i];\n    var itemKey = getItemKey(item, key);\n    if (itemKey) {\n      keyIndex[itemKey] = i;\n    } else {\n      free.push(item);\n    }\n  }\n  return {\n    keyIndex: keyIndex,\n    free: free\n  }\n}\n")])])]),t("p",[e._v("getItemKey 代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function getItemKey(item, key) {\n  if (!item || !key) {\n    return;\n  }\n  return typeof key === 'string' ? item[key] : key[item]\n}\n")])])]),t("p",[e._v("执行代码编程如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var oldMap = {\n  keyIndex: {\n    1: 0, \n    2: 1,\n    3: 2,\n    4: 3,\n    5: 4, \n    6: 5\n  },\n  free: []\n}\nvar newMap = makeKeyIndexAndFree(newList, key); 输出如下：\nvar newMap = {\n  free: [],\n  keyIndex: {\n    1: 2,\n    2: 0,\n    3: 1\n  }\n}\n")])])]),t("h5",{attrs:{id:"注意：上面的是把-id-xx-中的xx当做键，-但是当xx是数字的话，他会把数字当做索引位置来存储。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意：上面的是把-id-xx-中的xx当做键，-但是当xx是数字的话，他会把数字当做索引位置来存储。","aria-hidden":"true"}},[e._v("#")]),e._v(" 注意：上面的是把{id: xx} 中的xx当做键， 但是当xx是数字的话，他会把数字当做索引位置来存储。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var newFree = newMap.free = [];\nvar oldKeyIndex = oldMap.keyIndex;\nvar newKeyIndex = newMap.keyIndex;\n\nvar moves = [];\nvar children = [];\nvar i = 0;\nvar freeIndex = 0;\nvar item;\nvar itemKey;\n\nwhile(i < oldList.length) {\n  item = oldList[i];\n  itemKey = getItemKey(item, key);\n  if(itemKey) {\n    if(!newKeyIndex.hasOwnProperty(itemKey)) {\n      children.push(null);\n    } else {\n      var newItemIndex = newKeyIndex[itemKey];\n      children.push(newList[newItemIndex]);\n    }\n  } else {\n    var freeItem = newFree[freeIndex++];\n    children.push(freeItem || null);\n  }\n  i++;\n}\n")])])]),t("p",[e._v("while循环旧节点oldList，获取其某一项，比如 {id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}, 然后根据键名获取某一项的值，分别为：1,2,3,4,5,6。\n然后判断 新节点中的 newKeyIndex 是否有该属性键名，newKeyIndex = {1: 2, 2: 0, 3: 1}, 判断newKeyIndex 是否有属性 1, 2, 3, 4, 5, 6, 如果没有的话，把null放到children数组里面去，如果有的话，存入children数组里面去，因此children的值变为如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("children = [\n  {id: 1},\n  {id: 2},\n  {id: 3},\n  null,\n  null,\n  null\n];\n\n// 删除不存在的项\nvar simulateList = children.slice(0);\ni = 0;\nwhile (i < simulateList.length) {\n  if (simulateList[i] === null) {\n    remove(i);\n    // 调用该方法执行删除\n    removeSimulate(i);\n  } else {\n    i++;\n  }\n}\n")])])]),t("p",[e._v("把children数组的值赋值到 simulateList列表中，如果某一项等于null的话，调用 remove(i)方法，把null值以对象的形式保存到moves数组里面去，\n同时删除simulateList列表中的null数据。\n代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function remove(index) {\n  var move = {index: index, type: 0};\n  moves.push(move);\n}\nfunction removeSimulate(index) {\n  simulateList.splice(index, 1);\n}\nsimulateList 数据变成如下：\nsimulateList = [\n  {id： 1},\n  {id:  2},\n  {id:  3}\n];\n")])])]),t("p",[e._v("因此 moves 变成如下数据：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var moves = [\n  {index: 3, type: 0},\n  {index: 3, type: 0},\n  {index: 3, type: 0}\n];\n")])])]),t("p",[e._v("再执行如下代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var j = i = 0;\nwhile (i < newList.length) {\n  item = newList[i];\n  itemKey = getItemKey(item, key);\n\n  var simulateItem = simulateList[j];\n  var simulateItemKey = getItemKey(simulateItem, key);\n  if (simulateItem) {\n    if (itemKey === simulateItemKey) {\n      j++;\n    } else {\n      // 新的一项，插入\n      if (!oldKeyIndex.hasOwnProperty(itemKey)) {\n        insert(i, item);\n      } else {\n        var nextItemKey = getItemKey(simulateList[j + 1], key);\n        if (nextItemKey === itemKey) {\n          remove(i);\n          removeSimulate(j);\n          j++;\n        } else {\n          insert(i, item);\n        }\n      }\n    }\n  } else {\n    insert(i, item);\n  }\n  i++;\n} \n")])])]),t("p",[e._v("遍历新节点数据newList var newList = [{id: 2}, {id: 3}, {id: 1}]; 然后 itemKey = getItemKey(item, key); 那么itemKey=2, 3, 1\nvar simulateItem = simulateList[j];\nsimulateList的值如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("simulateList = [\n  {id： 1},\n  {id:  2},\n  {id:  3}\n];\n")])])]),t("p",[e._v("获取simulateList数组中的某一项，然后\nvar simulateItemKey = getItemKey(simulateItem, key);\n因此 simulateItemKey值依次变为1， 2， 3; 先循环最外层的 新数据 2， 3，1，然后在循环内层 旧数据 1, 2 ,3,\n判断 itemKey === simulateItemKey 是否相等，相等的话 什么都不做， 执行下一次循环，j++; 否则的话，先判断是否在旧节点oldKeyIndex\n能否找到新节点的值；oldKeyIndex 数据如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  1: 0, \n  2: 1,\n  3: 2,\n  4: 3,\n  5: 4, \n  6: 5\n}\n")])])]),t("p",[e._v("如果没有找到该键名的话，说明该新节点数据项就是新增的，那就新增一项，新增的代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function insert(index, item) {\n  var move = {index: index, item: item, type: 1};\n  moves.push(move);\n}\n")])])]),t("p",[e._v("因此moves代码继续新增一项，type为1就是新增的。否则的话，获取simulateList中的下一个数据值，进行对比，如果能找到的话，执行remove(i)方法，因此moves再新加一项\n{type:0, index: i}; 此时 j = 0; 删除原数组的第一项，然后继续循环上面一样的操作。")]),e._v(" "),t("h5",{attrs:{id:"整个思路重新整理一遍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整个思路重新整理一遍","aria-hidden":"true"}},[e._v("#")]),e._v(" 整个思路重新整理一遍:")]),e._v(" "),t("p",[e._v("var before = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];\nvar after = [{id: 4}, {id: 3}, {id: 2},{id: 1}];\nvar diffs = diff.diff(before, after, 'id');")]),e._v(" "),t("p",[e._v("上面的代码初始化，原数据 before， 新数据 after，key键为id，\noldMap 值为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("oldMap = {\n  keyIndex: {\n    1: 0,\n    2: 1,\n    3: 2,\n    4: 3, \n    5: 4,\n    6: 5\n  }\n}\n")])])]),t("p",[e._v("newMap的值为")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("newMap = {\n  keyIndex: {\n    1: 3,\n    2: 2,\n    3: 1,\n    4: 0\n  }\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("oldKeyIndex = oldMap.keyIndex = {\n  1: 0,\n  2: 1,\n  3: 2,\n  4: 3, \n  5: 4,\n  6: 5\n}\nvar newKeyIndex = newMap.keyIndex = {\n  1: 3,\n  2: 2,\n  3: 1,\n  4: 0\n};\n")])])]),t("p",[e._v("遍历 before，获取某一项的值，因此分别为1，2，3，4，5，6；判断newKeyIndex是否有该值，如果没有的话，该它置为null，保存到 children数组里面去；\n因此")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("children = [\n  {id: 1},\n  {id: 2},\n  {id: 3},\n  {id: 4},\n  null,\n  null\n]\n")])])]),t("p",[e._v("把children赋值到 simulateList 数组里面去，然后对simulateList数组去掉null值，因此simulateList值变为如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("simulateList = [\n  {id: 1},\n  {id: 2},\n  {id: 3},\n  {id: 4}\n]\nmoves = [\n  {\n    type: 0,\n    index: 4\n  },\n  {\n    type: 0,\n    index: 4\n  }\n]\n")])])]),t("p",[e._v("最后遍历新节点 newList = [{id: 4}, {id: 3}, {id: 2},{id: 1}]; 获取该键值分别为：4, 3, 2, 1;\n获取源数组simulateList里面的键值为 1, 2 , 3, 4;")]),e._v(" "),t("p",[e._v("所以 4, 3, 2, 1 遍历 和 1, 2, 3, 4 遍历判断是否相等思路如下：")]),e._v(" "),t("ol",[t("li",[e._v("遍历newList键值 为 4， 先和 1比较，如果相等的话，j++，跳到下一个内部循环，否则的话，先判断该键是否在oldKeyIndex里面，如果不存在的话，说明是新增的，否则的话就进入else语句，判断simulateList下一个值2 是否和 4 相等，不相等的话，直接插入值到数组的第一个位置上去，因此 moves的值变为如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("moves = [\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 1,\n      index: 0,\n      item: {id: 4}\n    }\n]\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("同样的道理 ，把 遍历newList的第二项 3， 和第一步一样的操作，最后3也是新增的，如下moves的值变为如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("moves = [\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 1,\n      index: 0,\n      item: {id: 4}\n    },\n    {\n      type: 1,\n      index: 1,\n      item: {id: 3}\n    }\n]\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("同样，遍历newList的第三项值为2， 和第一步操作，进入else语句，第一个值不符合，接着遍历第二个值，相等，就做删除操作，因此moves变为如下值：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("moves = [\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 1,\n      index: 0,\n      item: {id: 4}\n    },\n    {\n      type: 1,\n      index: 1,\n      item: {id: 3}\n    },\n    {\n      type: 0,\n      index: 2\n    }\n]\n")])])]),t("p",[e._v("且 oldList被删除一项，此时j = 0, 所以被删除掉第一项 因此 oldList = [2, 3, 4];")]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("同样，遍历 newList的第四项值为 1， 和第一步操作一样，值都不相等，因此做插入操作，因此moves值变为")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("moves = [\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 0,\n      index: 4\n    },\n    {\n      type: 1,\n      index: 0,\n      item: {id: 4}\n    },\n    {\n      type: 1,\n      index: 1,\n      item: {id: 3}\n    },\n    {\n      type: 0,\n      index: 2\n    },\n    {\n      type: 1,\n      index: 3,\n      item: {id: 1}\n    }\n]\n")])])]),t("p",[e._v("最后以对象的方式 返回 moves 和 children。")])])}],!1,null,null,null);n.default=a.exports}}]);