(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{212:function(t,a,i){"use strict";i.r(a);var e=i(0),r=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("div",{staticClass:"content"},[i("h1",{attrs:{id:"diff算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#diff算法","aria-hidden":"true"}},[t._v("#")]),t._v(" Diff算法")]),t._v(" "),i("h4",{attrs:{id:"_1、前言介绍"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1、前言介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、前言介绍")]),t._v(" "),i("div",{staticClass:"tip custom-block"},[i("p",{staticClass:"custom-block-title"},[t._v("Introduction")]),t._v(" "),i("p",[t._v("React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。")])]),t._v(" "),i("h4",{attrs:{id:"_1、什么是dom-diff算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是dom-diff算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、什么是DOM Diff算法")]),t._v(" "),i("ul",[i("li",[t._v("Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。")]),t._v(" "),i("li",[t._v("即给定任意两棵树，找到最少的转换步骤。达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度由O(n^3)直接降低到O(n)")])]),t._v(" "),i("h4",{attrs:{id:"_3、diff算法的作用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3、diff算法的作用","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、Diff算法的作用")]),t._v(" "),i("p",[t._v("计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。")]),t._v(" "),i("h5",{attrs:{id:"a-传统diff算法的作用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#a-传统diff算法的作用","aria-hidden":"true"}},[t._v("#")]),t._v(" a.传统diff算法的作用")]),t._v(" "),i("p",[t._v("计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。\nReact 使用 JSX 来替代常规的 JavaScript")]),t._v(" "),i("h4",{attrs:{id:"_4、调和"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4、调和","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、调和")]),t._v(" "),i("ul",[i("li",[t._v("将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。")]),t._v(" "),i("li",[t._v("React diff算法是调和的具体实现。")])]),t._v(" "),i("h4",{attrs:{id:"_5、diff策略"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_5、diff策略","aria-hidden":"true"}},[t._v("#")]),t._v(" 5、diff策略")]),t._v(" "),i("p",[t._v("React用三大策略将O(n^3)复杂度转化为O(n)复杂度")]),t._v(" "),i("ol",[i("li",[i("blockquote",[i("p",[t._v("策略一（tree diff）：\nWeb UI中DOM节点跨层级的移动操作特别少，可以忽略不计。新旧DOM树逐层对比的过程就是tree diff；当DOM树逐层对比完成后，即可找到所有需要被更新的元素；")])])]),t._v(" "),i("li",[i("blockquote",[i("p",[t._v("策略二（component diff）：\n拥有相同类的两个组件 生成相似的树形结构，暂时认为该组件不需要被更新；\n拥有不同类的两个组件 生成不同的树形结构。将旧的组件移除并创建新的组件，同时将组件追加到页面；")])])]),t._v(" "),i("li",[i("blockquote",[i("p",[t._v("策略三（element diff）：\n对于同一层级的一组子节点，通过唯一id区分。如果两个组件类型相同，则需要进行元素级别的对比，即element diff；")])])])])])}],!1,null,null,null);a.default=r.exports}}]);