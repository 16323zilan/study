<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Diff算法 | 前端知识点总结</title>
    <meta name="description" content="开花的树">
    <link rel="icon" href="/study/logo.png">
  <link rel="manifest" href="/study/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/study/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/study/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/study/assets/css/styles.ea8eda20.css" as="style"><link rel="preload" href="/study/assets/js/app.ea8eda20.js" as="script"><link rel="preload" href="/study/assets/js/41.54278bf9.js" as="script"><link rel="prefetch" href="/study/assets/css/1.styles.9a4bd71a.css"><link rel="prefetch" href="/study/assets/css/2.styles.fab7f89c.css"><link rel="prefetch" href="/study/assets/css/3.styles.0292a01e.css"><link rel="prefetch" href="/study/assets/css/4.styles.5640a71e.css"><link rel="prefetch" href="/study/assets/css/5.styles.c0ce815d.css"><link rel="prefetch" href="/study/assets/css/6.styles.fcb95dc6.css"><link rel="prefetch" href="/study/assets/css/7.styles.c8b06cc2.css"><link rel="prefetch" href="/study/assets/js/1.9a4bd71a.js"><link rel="prefetch" href="/study/assets/js/10.e058a7e5.js"><link rel="prefetch" href="/study/assets/js/11.5393a9a6.js"><link rel="prefetch" href="/study/assets/js/12.85b9f659.js"><link rel="prefetch" href="/study/assets/js/13.fab64d1d.js"><link rel="prefetch" href="/study/assets/js/14.f73d840e.js"><link rel="prefetch" href="/study/assets/js/15.d28057ad.js"><link rel="prefetch" href="/study/assets/js/16.eae80edc.js"><link rel="prefetch" href="/study/assets/js/17.94bdb325.js"><link rel="prefetch" href="/study/assets/js/18.18f2e4d3.js"><link rel="prefetch" href="/study/assets/js/19.73b3cad5.js"><link rel="prefetch" href="/study/assets/js/2.fab7f89c.js"><link rel="prefetch" href="/study/assets/js/20.41cbc980.js"><link rel="prefetch" href="/study/assets/js/21.ac0b4f36.js"><link rel="prefetch" href="/study/assets/js/22.27544958.js"><link rel="prefetch" href="/study/assets/js/23.381f8e14.js"><link rel="prefetch" href="/study/assets/js/24.6688820c.js"><link rel="prefetch" href="/study/assets/js/25.0f3cd4e0.js"><link rel="prefetch" href="/study/assets/js/26.1587fd22.js"><link rel="prefetch" href="/study/assets/js/27.8c8bf67b.js"><link rel="prefetch" href="/study/assets/js/28.8398db86.js"><link rel="prefetch" href="/study/assets/js/29.250aa4f0.js"><link rel="prefetch" href="/study/assets/js/3.0292a01e.js"><link rel="prefetch" href="/study/assets/js/30.0ef8d19e.js"><link rel="prefetch" href="/study/assets/js/31.6f5025b5.js"><link rel="prefetch" href="/study/assets/js/32.ad388b67.js"><link rel="prefetch" href="/study/assets/js/33.1bb7409f.js"><link rel="prefetch" href="/study/assets/js/34.65b99507.js"><link rel="prefetch" href="/study/assets/js/35.7012f26e.js"><link rel="prefetch" href="/study/assets/js/36.e577c804.js"><link rel="prefetch" href="/study/assets/js/37.65cfbec8.js"><link rel="prefetch" href="/study/assets/js/38.50303de0.js"><link rel="prefetch" href="/study/assets/js/39.358f53b2.js"><link rel="prefetch" href="/study/assets/js/4.5640a71e.js"><link rel="prefetch" href="/study/assets/js/40.45472df0.js"><link rel="prefetch" href="/study/assets/js/42.b2e466da.js"><link rel="prefetch" href="/study/assets/js/43.ee7cab7b.js"><link rel="prefetch" href="/study/assets/js/44.0e9444d0.js"><link rel="prefetch" href="/study/assets/js/45.1415b803.js"><link rel="prefetch" href="/study/assets/js/46.bdc84e10.js"><link rel="prefetch" href="/study/assets/js/47.008bfdb4.js"><link rel="prefetch" href="/study/assets/js/48.97e7870d.js"><link rel="prefetch" href="/study/assets/js/49.d61ca456.js"><link rel="prefetch" href="/study/assets/js/5.c0ce815d.js"><link rel="prefetch" href="/study/assets/js/50.664d32ab.js"><link rel="prefetch" href="/study/assets/js/51.386a7ad5.js"><link rel="prefetch" href="/study/assets/js/52.a6621eec.js"><link rel="prefetch" href="/study/assets/js/53.0268e383.js"><link rel="prefetch" href="/study/assets/js/54.ccccaca0.js"><link rel="prefetch" href="/study/assets/js/55.5b9d26be.js"><link rel="prefetch" href="/study/assets/js/56.64fafe6a.js"><link rel="prefetch" href="/study/assets/js/57.41d34f31.js"><link rel="prefetch" href="/study/assets/js/58.f9f5d87b.js"><link rel="prefetch" href="/study/assets/js/59.d084f0d6.js"><link rel="prefetch" href="/study/assets/js/6.fcb95dc6.js"><link rel="prefetch" href="/study/assets/js/60.1942bb51.js"><link rel="prefetch" href="/study/assets/js/61.da788876.js"><link rel="prefetch" href="/study/assets/js/62.fd979fb1.js"><link rel="prefetch" href="/study/assets/js/63.ff52fef0.js"><link rel="prefetch" href="/study/assets/js/64.2ce7207b.js"><link rel="prefetch" href="/study/assets/js/65.11fb12f7.js"><link rel="prefetch" href="/study/assets/js/66.6a6f1978.js"><link rel="prefetch" href="/study/assets/js/67.634b65a1.js"><link rel="prefetch" href="/study/assets/js/68.76b6162d.js"><link rel="prefetch" href="/study/assets/js/69.9b398548.js"><link rel="prefetch" href="/study/assets/js/7.c8b06cc2.js"><link rel="prefetch" href="/study/assets/js/8.58800656.js"><link rel="prefetch" href="/study/assets/js/9.a069f996.js">
    <link rel="stylesheet" href="/study/assets/css/styles.ea8eda20.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study/" class="home-link router-link-active"><!----> <span class="site-name">前端知识点总结</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study/zh/standard/Start.html" class="nav-link">快速搭建开发环境</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">项目相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/zh/standard/Standard.html" class="nav-link">前端规范</a></li><li class="dropdown-item"><!----> <a href="/study/zh/standard/Project.html" class="nav-link">项目流程</a></li><li class="dropdown-item"><!----> <a href="/study/zh/standard/Cooperation.html" class="nav-link">前后端交互</a></li><li class="dropdown-item"><!----> <a href="/study/zh/standard/Compatibility.html" class="nav-link">移动端兼容问题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知名公司面试题</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/zh/interview/index.html" class="nav-link">面试必看</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/question.html" class="nav-link">经典面试</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/Algorithm.html" class="nav-link">算法题</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/ali.html" class="nav-link">阿里巴巴</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/longhu.html" class="nav-link">龙湖地产</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识点笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/zh/interface/Mind.html" class="nav-link">在线思维导图</a></li><li class="dropdown-item"><!----> <a href="/study/zh/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/study/zh/react/" class="nav-link router-link-active">React</a></li><li class="dropdown-item"><!----> <a href="/study/zh/miniapp/" class="nav-link">小程序</a></li></ul></div></div> <a href="https://github.com/16323zilan/study" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study/zh/standard/Start.html" class="nav-link">快速搭建开发环境</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">项目相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/zh/standard/Standard.html" class="nav-link">前端规范</a></li><li class="dropdown-item"><!----> <a href="/study/zh/standard/Project.html" class="nav-link">项目流程</a></li><li class="dropdown-item"><!----> <a href="/study/zh/standard/Cooperation.html" class="nav-link">前后端交互</a></li><li class="dropdown-item"><!----> <a href="/study/zh/standard/Compatibility.html" class="nav-link">移动端兼容问题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知名公司面试题</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/zh/interview/index.html" class="nav-link">面试必看</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/question.html" class="nav-link">经典面试</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/Algorithm.html" class="nav-link">算法题</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/ali.html" class="nav-link">阿里巴巴</a></li><li class="dropdown-item"><!----> <a href="/study/zh/interview/longhu.html" class="nav-link">龙湖地产</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识点笔记</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/zh/interface/Mind.html" class="nav-link">在线思维导图</a></li><li class="dropdown-item"><!----> <a href="/study/zh/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/study/zh/react/" class="nav-link router-link-active">React</a></li><li class="dropdown-item"><!----> <a href="/study/zh/miniapp/" class="nav-link">小程序</a></li></ul></div></div> <a href="https://github.com/16323zilan/study" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav> <div class="carbon-ads"></div> <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>React知识点</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/study/zh/react/" class="sidebar-link">React</a></li><li><a href="/study/zh/react/JSX.html" class="sidebar-link">JSX</a></li><li><a href="/study/zh/react/MVVM.html" class="sidebar-link">MVVM</a></li><li><a href="/study/zh/react/Props.html" class="sidebar-link">Props</a></li><li><a href="/study/zh/react/React生命周期.html" class="sidebar-link">React生命周期</a></li><li><a href="/study/zh/react/React组件.html" class="sidebar-link">React组件</a></li><li><a href="/study/zh/react/React路由.html" class="sidebar-link">React路由</a></li><li><a href="/study/zh/react/redux.html" class="sidebar-link">Redux</a></li><li><a href="/study/zh/react/redux中间件.html" class="sidebar-link">Redux中间件</a></li><li><a href="/study/zh/react/组件通信.html" class="sidebar-link">组件通信</a></li><li><a href="/study/zh/react/高阶组件.html" class="sidebar-link">高阶组件</a></li><li><a href="/study/zh/react/Diff算法.html" class="active sidebar-link">Diff算法</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="diff算法"><a href="#diff算法" aria-hidden="true" class="header-anchor">#</a> Diff算法</h1> <h4 id="_1、前言介绍"><a href="#_1、前言介绍" aria-hidden="true" class="header-anchor">#</a> 1、前言介绍</h4> <div class="tip custom-block"><p class="custom-block-title">Introduction</p> <p>React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。</p></div> <h4 id="_1、什么是dom-diff算法"><a href="#_1、什么是dom-diff算法" aria-hidden="true" class="header-anchor">#</a> 1、什么是DOM Diff算法</h4> <ul><li>Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。</li> <li>即给定任意两棵树，找到最少的转换步骤。达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度由O(n^3)直接降低到O(n)</li></ul> <h4 id="_3、diff算法的作用"><a href="#_3、diff算法的作用" aria-hidden="true" class="header-anchor">#</a> 3、Diff算法的作用</h4> <p>计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。</p> <h5 id="a-传统diff算法的作用"><a href="#a-传统diff算法的作用" aria-hidden="true" class="header-anchor">#</a> a.传统diff算法的作用</h5> <p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。
React 使用 JSX 来替代常规的 JavaScript</p> <h4 id="_4、调和"><a href="#_4、调和" aria-hidden="true" class="header-anchor">#</a> 4、调和</h4> <ul><li>将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。</li> <li>React diff算法是调和的具体实现。</li></ul> <h4 id="_5、diff策略"><a href="#_5、diff策略" aria-hidden="true" class="header-anchor">#</a> 5、diff策略</h4> <p>React用三大策略将O(n^3)复杂度转化为O(n)复杂度,执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同。</p> <blockquote><p>策略一（tree diff）：</p></blockquote> <p>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。新旧DOM树逐层对比的过程就是tree diff；当DOM树逐层对比完成后，即可找到所有需要被更新的元素,这样只需要对DOM树进行一次遍历，就可以完成整个树的比较;复杂度变为O(n)。</p> <p>Tree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，A节点及其子节点被整个移动到D节点下面去，由于React只会简单的考虑同级节点的位置变换，而对于不同层级的节点，只有创建和删除操作，所以直接删掉A、B、C组件；继续第三层，当D发现多了一个子节点A，就会创建新的A作为其子节点,重新创建A、B、C组件。此时，diff的执行情况是：</p> <ul><li>createA--&gt;createB--&gt;createC--&gt;deleteA
<img src="https://img-blog.csdn.net/2018071718264787" alt="cmd-markdown-Tree DIFF"></li></ul> <p>由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是会进行删除，重新创建的动作，这是一种很影响React性能的操作。因此官方也不建议进行DOM节点跨层级的操作。</p> <blockquote><p>策略二（component diff）：</p></blockquote> <ul><li>拥有相同类的两个组件 生成相似的树形结构，暂时认为该组件不需要被更新；</li> <li>拥有不同类的两个组件 生成不同的树形结构。将旧的组件移除并创建新的组件，同时将组件追加到页面。</li> <li>如果是同一个类型的组件，有可能经过一轮Virtual DOM比较下来，并没有发生变化。如果我们能够提前确切知道这一点，那么就可以省下大量的diff运算时间。因此，React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。</li></ul> <p>如下图所示，当组件D变为组件G时，即使这两个组件结构相似，一旦React判断D和G是不用类型的组件，就不会比较两者的结构，而是直接删除组件D，重新创建组件G及其子节点。虽然当两个组件是不同类型但结构相似时，进行diff算法分析会影响性能，但是毕竟不同类型的组件存在相似DOM树的情况在实际开发过程中很少出现，因此这种极端因素很难在实际开发过程中造成重大影响。</p> <p><img src="https://img-blog.csdn.net/20180717182802621" alt="cmd-markdown-Tree DIFF"></p> <p>如图所示，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建。</p> <blockquote><p>策略三（element diff）：</p></blockquote> <p>Element DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可</p> <p><img src="https://img-blog.csdn.net/20180717182842111" alt="cmd-markdown-Element DIFF"></p> <h4 id="_6、列表对比算法源码分析"><a href="#_6、列表对比算法源码分析" aria-hidden="true" class="header-anchor">#</a> 6、列表对比算法源码分析</h4> <h5 id="该js的作用是：深度遍历两个列表数据，每层的节点进行对比，记录下每个节点的差异。并返回该对象的差异。"><a href="#该js的作用是：深度遍历两个列表数据，每层的节点进行对比，记录下每个节点的差异。并返回该对象的差异。" aria-hidden="true" class="header-anchor">#</a> 该js的作用是：深度遍历两个列表数据，每层的节点进行对比，记录下每个节点的差异。并返回该对象的差异。</h5> <p>@return {Object} {children: [], moves: [] }
children 是源列表 根据 新列表返回 移动或新增的数据。</p> <p>比如</p> <div class="language- extra-class"><pre class="language-text"><code>oldList = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];
newList = [{id: 2}, {id: 3}, {id: 1}]; 
</code></pre></div><p>最后返回的</p> <div class="language- extra-class"><pre class="language-text"><code>children = [
  {id: 1},
  {id: 2},
  {id: 3},
  null,
  null,
  null
 ]
</code></pre></div><p>moves 是源列表oldList 根据新列表newList 返回的操作，children为null的话，依次删除掉掉，因此返回的是</p> <div class="language- extra-class"><pre class="language-text"><code>moves = [
  {type: 0, index:3},
  {type: 0, index: 3},
  {type: 0, index: 3},
  {type: 0, index: 0},
  {type: 1, index: 2, item: {id: 1}}
]
</code></pre></div><h5 id="type-0-是删除操作，-type-1-是新增操作"><a href="#type-0-是删除操作，-type-1-是新增操作" aria-hidden="true" class="header-anchor">#</a> type = 0 是删除操作， type = 1 是新增操作</h5> <div class="language- extra-class"><pre class="language-text"><code>oldList = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}]; 
newList = [{id: 2}, {id: 3}, {id: 1}];
</code></pre></div><p>所以oldList根据newList来对比，{id: 4} 和 {id: 5} 和 {id: 6} 在新节点 newList没有找到，因此在moves设置为 {type:0, index:3},
所以oldList数据依次变为 [{id: 1}, {id: 2}, {id: 3}, {id: 5}, {id: 6}] 和  [{id: 1}, {id: 2}, {id: 3}, {id: 6}] 和  [{id: 1}, {id: 2}, {id: 3}]
每次在moves存储了一次的话，原数组会删掉当前的一项，因此oldList 变为 [{id: 1}, {id: 2}, {id: 3}], newList 为 [{id: 2}, {id: 3}, {id: 1}],
然后各自取出该值进行比较，也就是 oldList变为 [1, 2, 3], newList变为 [2, 3, 1]; 因此oldList相对于 newList来讲的话，第一项不相同就删掉该项 所以moves新增一项{type: 0, index:0}, index从0开始的，表示第一项被删除，然后第二项1被添加，因此moves再加一项 {type: 1, index:2, item: {id: 1}}；</p> <h5 id="理解代码如下："><a href="#理解代码如下：" aria-hidden="true" class="header-anchor">#</a> 理解代码如下：</h5> <p>该方法需要传入三个参数 oldLsit, newList, key;
oldList 和 newList 是原始数组 和 新数组， key是根据键名进行匹配。</p> <p>现在分别对oldList 和 newList 传值如下数据：
var oldLsit = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];
var newList = [{id: 2}, {id: 3}, {id: 1}];</p> <p>因此 var oldMap = makeKeyIndexAndFree(oldList, key);
makeKeyIndexAndFree代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function makeKeyIndexAndFree(list, key) {
  var keyIndex = {};
  var free = [];
  for (var i = 0, len = list.length; i &lt; len; i++) {
    var item = list[i];
    var itemKey = getItemKey(item, key);
    if (itemKey) {
      keyIndex[itemKey] = i;
    } else {
      free.push(item);
    }
  }
  return {
    keyIndex: keyIndex,
    free: free
  }
}
</code></pre></div><p>getItemKey 代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function getItemKey(item, key) {
  if (!item || !key) {
    return;
  }
  return typeof key === 'string' ? item[key] : key[item]
}
</code></pre></div><p>执行代码编程如下：</p> <div class="language- extra-class"><pre class="language-text"><code>var oldMap = {
  keyIndex: {
    1: 0, 
    2: 1,
    3: 2,
    4: 3,
    5: 4, 
    6: 5
  },
  free: []
}
var newMap = makeKeyIndexAndFree(newList, key); 输出如下：
var newMap = {
  free: [],
  keyIndex: {
    1: 2,
    2: 0,
    3: 1
  }
}
</code></pre></div><h5 id="注意：上面的是把-id-xx-中的xx当做键，-但是当xx是数字的话，他会把数字当做索引位置来存储。"><a href="#注意：上面的是把-id-xx-中的xx当做键，-但是当xx是数字的话，他会把数字当做索引位置来存储。" aria-hidden="true" class="header-anchor">#</a> 注意：上面的是把{id: xx} 中的xx当做键， 但是当xx是数字的话，他会把数字当做索引位置来存储。</h5> <div class="language- extra-class"><pre class="language-text"><code>var newFree = newMap.free = [];
var oldKeyIndex = oldMap.keyIndex;
var newKeyIndex = newMap.keyIndex;

var moves = [];
var children = [];
var i = 0;
var freeIndex = 0;
var item;
var itemKey;

while(i &lt; oldList.length) {
  item = oldList[i];
  itemKey = getItemKey(item, key);
  if(itemKey) {
    if(!newKeyIndex.hasOwnProperty(itemKey)) {
      children.push(null);
    } else {
      var newItemIndex = newKeyIndex[itemKey];
      children.push(newList[newItemIndex]);
    }
  } else {
    var freeItem = newFree[freeIndex++];
    children.push(freeItem || null);
  }
  i++;
}
</code></pre></div><p>while循环旧节点oldList，获取其某一项，比如 {id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}, 然后根据键名获取某一项的值，分别为：1,2,3,4,5,6。
然后判断 新节点中的 newKeyIndex 是否有该属性键名，newKeyIndex = {1: 2, 2: 0, 3: 1}, 判断newKeyIndex 是否有属性 1, 2, 3, 4, 5, 6, 如果没有的话，把null放到children数组里面去，如果有的话，存入children数组里面去，因此children的值变为如下：</p> <div class="language- extra-class"><pre class="language-text"><code>children = [
  {id: 1},
  {id: 2},
  {id: 3},
  null,
  null,
  null
];

// 删除不存在的项
var simulateList = children.slice(0);
i = 0;
while (i &lt; simulateList.length) {
  if (simulateList[i] === null) {
    remove(i);
    // 调用该方法执行删除
    removeSimulate(i);
  } else {
    i++;
  }
}
</code></pre></div><p>把children数组的值赋值到 simulateList列表中，如果某一项等于null的话，调用 remove(i)方法，把null值以对象的形式保存到moves数组里面去，
同时删除simulateList列表中的null数据。
代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function remove(index) {
  var move = {index: index, type: 0};
  moves.push(move);
}
function removeSimulate(index) {
  simulateList.splice(index, 1);
}
simulateList 数据变成如下：
simulateList = [
  {id： 1},
  {id:  2},
  {id:  3}
];
</code></pre></div><p>因此 moves 变成如下数据：</p> <div class="language- extra-class"><pre class="language-text"><code>var moves = [
  {index: 3, type: 0},
  {index: 3, type: 0},
  {index: 3, type: 0}
];
</code></pre></div><p>再执行如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>var j = i = 0;
while (i &lt; newList.length) {
  item = newList[i];
  itemKey = getItemKey(item, key);

  var simulateItem = simulateList[j];
  var simulateItemKey = getItemKey(simulateItem, key);
  if (simulateItem) {
    if (itemKey === simulateItemKey) {
      j++;
    } else {
      // 新的一项，插入
      if (!oldKeyIndex.hasOwnProperty(itemKey)) {
        insert(i, item);
      } else {
        var nextItemKey = getItemKey(simulateList[j + 1], key);
        if (nextItemKey === itemKey) {
          remove(i);
          removeSimulate(j);
          j++;
        } else {
          insert(i, item);
        }
      }
    }
  } else {
    insert(i, item);
  }
  i++;
} 
</code></pre></div><p>遍历新节点数据newList var newList = [{id: 2}, {id: 3}, {id: 1}]; 然后 itemKey = getItemKey(item, key); 那么itemKey=2, 3, 1
var simulateItem = simulateList[j];
simulateList的值如下：</p> <div class="language- extra-class"><pre class="language-text"><code>simulateList = [
  {id： 1},
  {id:  2},
  {id:  3}
];
</code></pre></div><p>获取simulateList数组中的某一项，然后
var simulateItemKey = getItemKey(simulateItem, key);
因此 simulateItemKey值依次变为1， 2， 3; 先循环最外层的 新数据 2， 3，1，然后在循环内层 旧数据 1, 2 ,3,
判断 itemKey === simulateItemKey 是否相等，相等的话 什么都不做， 执行下一次循环，j++; 否则的话，先判断是否在旧节点oldKeyIndex
能否找到新节点的值；oldKeyIndex 数据如下：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  1: 0, 
  2: 1,
  3: 2,
  4: 3,
  5: 4, 
  6: 5
}
</code></pre></div><p>如果没有找到该键名的话，说明该新节点数据项就是新增的，那就新增一项，新增的代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function insert(index, item) {
  var move = {index: index, item: item, type: 1};
  moves.push(move);
}
</code></pre></div><p>因此moves代码继续新增一项，type为1就是新增的。否则的话，获取simulateList中的下一个数据值，进行对比，如果能找到的话，执行remove(i)方法，因此moves再新加一项
{type:0, index: i}; 此时 j = 0; 删除原数组的第一项，然后继续循环上面一样的操作。</p> <h5 id="整个思路重新整理一遍"><a href="#整个思路重新整理一遍" aria-hidden="true" class="header-anchor">#</a> 整个思路重新整理一遍:</h5> <p>var before = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];
var after = [{id: 4}, {id: 3}, {id: 2},{id: 1}];
var diffs = diff.diff(before, after, 'id');</p> <p>上面的代码初始化，原数据 before， 新数据 after，key键为id，
oldMap 值为：</p> <div class="language- extra-class"><pre class="language-text"><code>oldMap = {
  keyIndex: {
    1: 0,
    2: 1,
    3: 2,
    4: 3, 
    5: 4,
    6: 5
  }
}
</code></pre></div><p>newMap的值为</p> <div class="language- extra-class"><pre class="language-text"><code>newMap = {
  keyIndex: {
    1: 3,
    2: 2,
    3: 1,
    4: 0
  }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>oldKeyIndex = oldMap.keyIndex = {
  1: 0,
  2: 1,
  3: 2,
  4: 3, 
  5: 4,
  6: 5
}
var newKeyIndex = newMap.keyIndex = {
  1: 3,
  2: 2,
  3: 1,
  4: 0
};
</code></pre></div><p>遍历 before，获取某一项的值，因此分别为1，2，3，4，5，6；判断newKeyIndex是否有该值，如果没有的话，该它置为null，保存到 children数组里面去；
因此</p> <div class="language- extra-class"><pre class="language-text"><code>children = [
  {id: 1},
  {id: 2},
  {id: 3},
  {id: 4},
  null,
  null
]
</code></pre></div><p>把children赋值到 simulateList 数组里面去，然后对simulateList数组去掉null值，因此simulateList值变为如下：</p> <div class="language- extra-class"><pre class="language-text"><code>simulateList = [
  {id: 1},
  {id: 2},
  {id: 3},
  {id: 4}
]
moves = [
  {
    type: 0,
    index: 4
  },
  {
    type: 0,
    index: 4
  }
]
</code></pre></div><p>最后遍历新节点 newList = [{id: 4}, {id: 3}, {id: 2},{id: 1}]; 获取该键值分别为：4, 3, 2, 1;
获取源数组simulateList里面的键值为 1, 2 , 3, 4;</p> <p>所以 4, 3, 2, 1 遍历 和 1, 2, 3, 4 遍历判断是否相等思路如下：</p> <ol><li>遍历newList键值 为 4， 先和 1比较，如果相等的话，j++，跳到下一个内部循环，否则的话，先判断该键是否在oldKeyIndex里面，如果不存在的话，说明是新增的，否则的话就进入else语句，判断simulateList下一个值2 是否和 4 相等，不相等的话，直接插入值到数组的第一个位置上去，因此 moves的值变为如下：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>moves = [
    {
      type: 0,
      index: 4
    },
    {
      type: 0,
      index: 4
    },
    {
      type: 1,
      index: 0,
      item: {id: 4}
    }
]
</code></pre></div><ol start="2"><li>同样的道理 ，把 遍历newList的第二项 3， 和第一步一样的操作，最后3也是新增的，如下moves的值变为如下：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>moves = [
    {
      type: 0,
      index: 4
    },
    {
      type: 0,
      index: 4
    },
    {
      type: 1,
      index: 0,
      item: {id: 4}
    },
    {
      type: 1,
      index: 1,
      item: {id: 3}
    }
]
</code></pre></div><ol start="3"><li>同样，遍历newList的第三项值为2， 和第一步操作，进入else语句，第一个值不符合，接着遍历第二个值，相等，就做删除操作，因此moves变为如下值：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>moves = [
    {
      type: 0,
      index: 4
    },
    {
      type: 0,
      index: 4
    },
    {
      type: 1,
      index: 0,
      item: {id: 4}
    },
    {
      type: 1,
      index: 1,
      item: {id: 3}
    },
    {
      type: 0,
      index: 2
    }
]
</code></pre></div><p>且 oldList被删除一项，此时j = 0, 所以被删除掉第一项 因此 oldList = [2, 3, 4];</p> <ol start="4"><li>同样，遍历 newList的第四项值为 1， 和第一步操作一样，值都不相等，因此做插入操作，因此moves值变为</li></ol> <div class="language- extra-class"><pre class="language-text"><code>moves = [
    {
      type: 0,
      index: 4
    },
    {
      type: 0,
      index: 4
    },
    {
      type: 1,
      index: 0,
      item: {id: 4}
    },
    {
      type: 1,
      index: 1,
      item: {id: 3}
    },
    {
      type: 0,
      index: 2
    },
    {
      type: 1,
      index: 3,
      item: {id: 1}
    }
]
</code></pre></div><p>最后以对象的方式 返回 moves 和 children。</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/16323zilan/study/edit/master/src/zh/react/Diff算法.md" target="_blank" rel="noopener noreferrer">帮助我们改进内容</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2019-5-16 13:35:06</span></div></div> <!----> <div class="bsa-cpc-wrapper"><div class="bsa-cpc"></div></div></div> <!----></div></div>
    <script src="/study/assets/js/app.ea8eda20.js" defer></script><script src="/study/assets/js/41.54278bf9.js" defer></script>
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?c3446600de53c605ba4f6c792e47dff9";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  </body>
</html>
